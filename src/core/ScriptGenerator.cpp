#include "ScriptGenerator.h"
#include <QMetaProperty>
#include <QDebug>
#include <QLayout>
#include <QTabWidget>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>

ScriptGenerator::ScriptGenerator()
{
}

QString ScriptGenerator::generate(QWidget *root)
{
    if (!root) return QString();
    
    // Limpar callbacks de gerações anteriores
    m_callbacks.clear();

    QString script;
    script += "#!/bin/bash\n";
    script += "# Generated by Showbox Studio\n\n";
    
    // Gerar funções de callback primeiro (antes do heredoc)
    QString callbacks = generateCallbacks();
    if (!callbacks.isEmpty()) {
        script += "# === Callback Functions ===\n";
        script += callbacks;
        script += "\n";
    }
    
    script += "showbox << EOD\n";

    // Criar uma janela principal implícita para conter os widgets do Canvas
    script += "add window \"Preview\" main_window width=800 height=600\n\n";

    // Assumindo que 'root' é o container onde os widgets foram soltos (ex: Canvas)
    const QObjectList &children = root->children();
    for (QObject *child : children) {
        if (QWidget *w = qobject_cast<QWidget*>(child)) {
            processWidget(w, script);
        }
    }

    script += "show\n";
    script += "EOD\n";
    return script;
}

void ScriptGenerator::processWidget(QWidget *widget, QString &script)
{
    if (!widget) return;
    
    // Ignorar widgets internos ou não gerenciados
    if (widget->property("showbox_ignore").toBool()) return;

    QString type = getShowboxType(widget);
    if (type.isEmpty()) return; // Não sabemos exportar este tipo

    // Extrair Título/Texto (Argumento posicional 2)
    QString title = "";
    QVariant textProp = widget->property("text");
    QVariant titleProp = widget->property("title");
    
    if (textProp.isValid() && !textProp.toString().isEmpty()) title = textProp.toString();
    else if (titleProp.isValid() && !titleProp.toString().isEmpty()) title = titleProp.toString();
    
    // Escapar aspas no título
    title.replace("\"", "\\\"");
    title = "\"" + title + "\"";

    // Extrair Nome (Argumento posicional 3)
    QString name = widget->objectName();
    if (name.isEmpty()) name = "unnamed_" + QString::number((quintptr)widget);

    // Coletar ações para geração de callbacks
    collectActions(widget, name);

    // Extrair Opções (Argumentos restantes)
    QString options = getPropertiesString(widget);
    
    // Adicionar referência ao callback se houver ações definidas
    if (widget->property("showbox_actions").isValid() && 
        !widget->property("showbox_actions").toString().isEmpty()) {
        // Para botões, o evento padrão é "clicked"
        if (type == "button" || type == "pushbutton") {
            options += QString(" action=\"%1_clicked\"").arg(name);
        }
    }
    
    // Formato: add type "title" name options...
    script += QString("add %1 %2 %3 %4\n").arg(type, title, name, options);

    // Recursão APENAS para containers conhecidos
    // Isso evita entrar em widgets complexos como ComboBox e listar seus componentes internos
    bool isContainer = (type == "window" || type == "groupbox" || type == "frame" || 
                        type == "tabwidget" || type == "page" ||
                        type == "hboxlayout" || type == "vboxlayout" || 
                        type == "gridlayout" || type == "formlayout" ||
                        type == "scrollarea");

    if (isContainer) {
        // Caso Especial: QTabWidget
        if (QTabWidget *tab = qobject_cast<QTabWidget*>(widget)) {
            for (int i = 0; i < tab->count(); ++i) {
                processWidget(tab->widget(i), script);
            }
        } 
        // Caso Padrão: Containers com Layout ou Filhos Diretos
        else {
            QList<QWidget*> childWidgets;
            if (widget->layout()) {
                QLayout *layout = widget->layout();
                for (int i = 0; i < layout->count(); ++i) {
                    if (QWidget *w = layout->itemAt(i)->widget()) {
                        childWidgets.append(w);
                    }
                }
            } else {
                for (QObject *child : widget->children()) {
                    if (QWidget *w = qobject_cast<QWidget*>(child)) {
                        childWidgets.append(w);
                    }
                }
            }
            // Processar filhos coletados
            for (QWidget *child : childWidgets) {
                processWidget(child, script);
            }
        }
    }
    
    // Fechamento de contexto para containers
    if (type == "groupbox" || type == "frame" || type == "tabwidget" || type == "page" ||
        type == "hboxlayout" || type == "vboxlayout" || type == "gridlayout" || type == "formlayout" ||
        type == "scrollarea") {
        script += QString("end %1\n").arg(type);
    }
}

QString ScriptGenerator::getShowboxType(QWidget *widget)
{
    // Prioridade 1: Propriedade explícita definida pela Factory
    QVariant typeProp = widget->property("showbox_type");
    if (typeProp.isValid() && !typeProp.toString().isEmpty()) {
        return typeProp.toString();
    }

    // Fallback: Tentativa de inferência por nome de classe (Legado/Depuração)
    const QMetaObject *meta = widget->metaObject();
    QString cls = meta->className(); // ex: "QPushButton", "QLabel"
    
    // Mapeamento manual
    if (cls.contains("Button")) {
        if (cls.contains("Check")) return "checkbox";
        if (cls.contains("Radio")) return "radiobutton";
        return "button"; 
    }
    if (cls.contains("Label")) return "label";
    if (cls.contains("LineEdit")) return "textbox";
    if (cls.contains("TextEdit")) return "textedit";
    if (cls.contains("SpinBox")) return "spinbox";
    if (cls.contains("Slider")) return "slider";
    if (cls.contains("ComboBox")) return "combobox";
    if (cls.contains("ListWidget") || cls.contains("ListView")) return "listbox";
    if (cls.contains("ProgressBar")) return "progressbar";
    if (cls.contains("GroupBox")) return "groupbox";
    if (cls.contains("TabWidget")) return "tabwidget";
    if (cls.contains("Frame")) return "frame";
    if (cls.contains("Table")) return "table";
    if (cls.contains("Calendar")) return "calendar";
    if (cls.contains("Line")) return "separator";
    
    if (cls.contains("ChartWidget")) return "chart";

    return "";
}

QString ScriptGenerator::getPropertiesString(QWidget *widget)
{
    QStringList parts;
    
    // Nota: Name, Text e Title já são passados como argumentos posicionais
    // no comando 'add', então não precisamos repeti-los aqui,
    // A MENOS que o parser suporte redundância ou precise deles para 'set'.
    // O ParserMain lê options com WidgetParserUtils::findValue/hasFlag.
    
    // Geometria
    if (widget->width() > 0 && widget->width() != 100 && widget->width() != 640) 
        parts << QString("width=%1").arg(widget->width());
    if (widget->height() > 0 && widget->height() != 30 && widget->height() != 480) 
        parts << QString("height=%1").arg(widget->height());

    // Booleanos
    if (widget->property("checked").isValid() && widget->property("checked").toBool()) 
        parts << "checked"; // Flag style
    
    // ParserMain usa flags para algumas coisas: 'checked', 'readonly', 'password'
    
    if (widget->property("readOnly").isValid() && widget->property("readOnly").toBool())
        parts << "readonly";
        
    if (widget->property("echoMode").isValid() && widget->property("echoMode").toInt() == 2) // Password
        parts << "password";

    // Valores numéricos
    if (widget->property("value").isValid())
        parts << QString("value=%1").arg(widget->property("value").toInt());
        
    if (widget->property("minimum").isValid())
        parts << QString("minimum=%1").arg(widget->property("minimum").toInt());
        
    if (widget->property("maximum").isValid())
        parts << QString("maximum=%1").arg(widget->property("maximum").toInt());

    // Cores (Custom)
    if (widget->property("background-color").isValid()) {
        QColor c = widget->property("background-color").value<QColor>();
        if (c.isValid()) parts << QString("bgcolor=%1").arg(c.name());
    }
    if (widget->property("text-color").isValid()) {
        QColor c = widget->property("text-color").value<QColor>();
        if (c.isValid()) parts << QString("fgcolor=%1").arg(c.name());
    }

    return parts.join(" ");
}

void ScriptGenerator::collectActions(QWidget *widget, const QString &widgetName)
{
    // Verificar se o widget tem ações definidas via propriedade JSON
    QVariant actionsVar = widget->property("showbox_actions");
    if (!actionsVar.isValid()) return;
    
    QString actionsJson = actionsVar.toString();
    if (actionsJson.isEmpty()) return;
    
    QJsonDocument doc = QJsonDocument::fromJson(actionsJson.toUtf8());
    if (!doc.isObject()) return;
    
    QJsonObject events = doc.object();
    for (auto it = events.begin(); it != events.end(); ++it) {
        QString eventName = it.key();  // "clicked", "changed", etc.
        QJsonArray actions = it.value().toArray();
        
        QString callbackName = QString("%1_%2").arg(widgetName, eventName);
        QStringList commands;
        
        for (const QJsonValue &actionVal : actions) {
            QJsonObject action = actionVal.toObject();
            QString type = action["type"].toString();
            
            if (type == "shell") {
                commands << action["command"].toString();
            } else if (type == "script") {
                commands << QString("source \"%1\"").arg(action["command"].toString());
            } else if (type == "callback") {
                commands << QString("echo \"%1\"").arg(action["command"].toString());
            } else if (type == "set") {
                QString target = action["target"].toString();
                QString prop = action["property"].toString();
                QString value = action["value"].toString();
                commands << QString("showbox set %1 %2 \"%3\"").arg(prop, target, value);
            } else if (type == "query") {
                QString target = action["target"].toString();
                QString variable = action["variable"].toString();
                commands << QString("%1=$(showbox query %2)").arg(variable, target);
            }
        }
        
        if (!commands.isEmpty()) {
            m_callbacks[callbackName] = commands;
        }
    }
}

QString ScriptGenerator::generateCallbacks()
{
    if (m_callbacks.isEmpty()) return QString();
    
    QString result;
    
    // Header com definição de variáveis globais úteis
    result += "# Variáveis predefinidas disponíveis em callbacks:\n";
    result += "#   $WIDGET_NAME  - Nome do widget que disparou o evento\n";
    result += "#   $WIDGET_VALUE - Valor atual do widget (se aplicável)\n";
    result += "#   $EVENT        - Nome do evento (clicked, changed, etc.)\n";
    result += "#   $TIMESTAMP    - Data/hora da execução\n\n";
    
    for (auto it = m_callbacks.begin(); it != m_callbacks.end(); ++it) {
        QString funcName = it.key();
        QStringList commands = it.value();
        
        // Extrair nome do widget e evento do nome da função (widgetname_event)
        int lastUnderscore = funcName.lastIndexOf('_');
        QString widgetName = funcName.left(lastUnderscore);
        QString eventName = funcName.mid(lastUnderscore + 1);
        
        result += QString("%1() {\n").arg(funcName);
        
        // Variáveis predefinidas
        result += QString("    local WIDGET_NAME=\"%1\"\n").arg(widgetName);
        result += QString("    local EVENT=\"%1\"\n").arg(eventName);
        result += "    local TIMESTAMP=$(date +\"%Y-%m-%d %H:%M:%S\")\n";
        result += QString("    local WIDGET_VALUE=$(showbox query %1 2>/dev/null || echo \"\")\n\n").arg(widgetName);
        
        for (const QString &cmd : commands) {
            result += QString("    %1\n").arg(cmd);
        }
        result += "}\n\n";
    }
    
    return result;
}

